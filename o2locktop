#!/usr/bin/env python
#-*- coding: utf-8 -*-

import util
import dlm
import printer
import keyboard
import threading
import sys
import signal
import argparse
import multiprocessing
import os

VERSION = "o2locktop 1.0.0"

def parse_args():
    description=""
    usage = \
"""
Usage: o2locktop [OPTIONS] MOUNTPOINT
       o2locktop -h|--help
       o2locktop -V|--version
[OPTIONS] can be:
       -o log file path
       -n other node IP/hostname
       -l number of lines to display

Monitor the MOUNTPOINT OCFS2 DLM lock statistics. 
Make sure passwordless SSH access between the nodes is set up.
Launch o2locktop script like the below command line, 
e.g. remote mode: "o2locktop -n node1 -n node2 -n node3 /mnt/shared".
     local mode : "o2locktop /mnt/shared".

Controls: 
Type "d" to diplay DLM lock statistics for each node.
Type "Ctrl+C" or "q" to exit o2locltop process.

Suggestion:
Please read the README.md file for more information.
"""
    parser = argparse.ArgumentParser(description=description, usage=None, prog='o2locktop', add_help=False)
    parser.add_argument('-n', metavar='host',
                        dest='host_list', action='append',
                        help='node address used for ssh')

    parser.add_argument('-o', metavar='log', dest='log',
                        action='store',
                        help='log path')

    parser.add_argument('-l', metavar='display length', dest='display_len', 
                        default=10,type=int,
                        action='store',
                        help='the line of the lock to show, default is 10')

    parser.add_argument('-V','--version',action="store_true", 
                        help='current version of o2locktop')

    parser.add_argument('-d','--debug',action="store_true",
                        help='show all the inode,include the system inode number')

    parser.add_argument('mount_point', nargs='?',
                        help='mount point like /mnt')

    parser.add_argument('-h','--help',action="store_true", 
                        help='show this help message and exit')

    args = parser.parse_args()

    node_list = []
    met_colon = False
    if args.version:
        print(VERSION)
        sys.exit(0)
    if args.help:
        print(usage)
        sys.exit(0)
    if args.display_len <= 0:
        util.eprint("o2locktop: error: The length of the line to show must be greater than 0")
        sys.exit(0)
    if args.display_len > 50:
        util.eprint("o2locktop: error: The length of the line to show must be less than 50")
        sys.exit(0)
    if args.host_list:
        if not args.mount_point:
            util.eprint("o2locktop: error: ocfs2 mount point is needed")
            print(usage)
            sys.exit(0)
        for i in args.host_list:
            node_list.append(i)

        return {
                "mode":"remote",
                "mount_node" : node_list[0],
                "mount_point" : args.mount_point,
                "node_list" : node_list,
                "log" : args.log,
                "display_len" : args.display_len,
                "debug" : args.debug
                }
    else:
        if not args.mount_point:
            util.eprint("o2locktop: error: ocfs2 mount point is needed")
            print(usage)
            sys.exit(0)
        return {
                "mode":"local",
                "mount_point" : args.mount_point,
                "log" : args.log,
                "display_len" : args.display_len,
                "debug" : args.debug
                }

    parser.print_help()
    sys.exit(0)

def connection_test(nodes,mount_point):
    assert(nodes != None and len(nodes) > 0)
    uuid = util.get_dlm_lockspace_mp(nodes[0], mount_point)    
    if not uuid:
        util.eprint("o2locktop: error: can't find the mount point: {}, please cheack and retry".format(mount_point))
        sys.exit(0)
    for node in nodes[1:]:
        if uuid != util.get_dlm_lockspace_mp(node, mount_point):
            util.eprint("o2locktop: error: can't find the shared storage in the cluster, "\
                                    "check if the node in the command line has input errors")
            sys.exit(0) 

def local_test(mount_point):
    uuid = util.get_dlm_lockspace_mp(None, mount_point)    
    if not uuid:
        util.eprint("o2locktop: error: can't find the mount point: {}, please cheack and retry".format(mount_point))
        sys.exit(0)

def main():
    args = parse_args()
    log = args["log"]
    display_len = args["display_len"] 
    debug = args["debug"]
    

    if args['mode'] == "remote":
        mount_host, mount_point = args["mount_node"], args["mount_point"]
        nodes = args["node_list"]
        connection_test(nodes, mount_point)
        lock_space_str = util.get_dlm_lockspace_mp(mount_host, mount_point)
        max_sys_inode_num = util.get_dlm_lockspace_max_sys_inode_number(mount_host, mount_point)
        mount_info = ':'.join([mount_host, mount_point])
    elif args['mode'] == "local":
        mount_point = args["mount_point"]
        local_test(mount_point)
        lock_space_str = util.get_dlm_lockspace_mp(None, mount_point)
        max_sys_inode_num = util.get_dlm_lockspace_max_sys_inode_number(None, mount_point)
        mount_info = mount_point

    if lock_space_str is None:
        print("Error while getting lockspace")
        sys.exit(0)

    if args["mode"] == "local":
        nodes = None

    printer_queue = multiprocessing.Queue()
    printer_process = multiprocessing.Process(target=printer.worker,
                                        args=(printer_queue, log),
                                        kwargs={"mount_info":mount_info}
                                    )
    lock_space_process = multiprocessing.Process(target=dlm.worker,
                                        args=(lock_space_str, max_sys_inode_num, debug, display_len, nodes, printer_queue)
                                        )

    printer_process.start()
    lock_space_process.start()

    keyboard.worker(printer_queue)

    lock_space_process.terminate()
    lock_space_process.join()

    #printer_process will exit on quit message
    #printer_process.terminate()
    printer_process.join()


    sys.exit(0)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        #print("Bye")
        keyboard.reset_terminal()
